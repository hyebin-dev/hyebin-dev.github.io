---
import Layout from "../../layouts/Layout.astro";
---

<Layout title="Tap Run 개발 회고 — hyebin-dev">
  <article class="article">
    <header class="article-header">
      <p class="article-tag">프로젝트 회고</p>
      <h1>Tap Run 개발 회고 — 콘솔 게임 하나를 끝까지</h1>
      <p class="article-sub">
        Enter 키 하나만으로 즐기는 콘솔 러닝 미니게임을 만들면서,
        모드 분리와 치트 방지, 랭킹 저장 구조를 어떻게 설계했는지 정리했습니다.
      </p>
      <div class="article-meta">
        <span>Stack · Java 11, 파일 I/O, OOP</span>
        <span>Repo · <a href="https://github.com/hyebin-dev/taprun" target="_blank" rel="noreferrer">taprun</a></span>
      </div>
    </header>

    <section>
      <h2>1. 왜 콘솔 게임부터 시작했나</h2>
      <p>
        처음에는 “Enter를 연타해서 기록을 재는 심플한 게임” 정도만 떠올렸습니다.
        하지만 콘솔 기반이라도 입력 타이밍, 난이도, 랭킹 저장을 직접 설계해 보면
        객체지향 구조 연습에 꽤 도움이 될 거라고 생각했습니다.
      </p>
      <p>
        그래서 단순한 one-shot 실습이 아니라,
        모드를 나누고 랭킹까지 포함된 <strong>하나의 완성된 미니게임</strong>을 목표로 잡았습니다.
      </p>
    </section>

    <section>
      <h2>2. 세 가지 게임 모드 구조</h2>
      <p>
        Tap Run은 Race / Monster / Vs AI 세 가지 모드로 구성되어 있습니다.
        공통으로 “Enter 입력을 반복하면서 진행 상황을 갱신한다”는 흐름을 가지고 있어서
        공통 인터페이스와 각 모드별 구현 클래스로 나누는 식으로 구조를 잡았습니다.
      </p>
      <ul>
        <li>Race Mode: 두 플레이어가 정해진 횟수만큼 더 빨리 입력하면 승리</li>
        <li>Monster Mode: 제한 시간 안에 몬스터 HP를 0으로 만들기</li>
        <li>Vs AI Mode: 난이도별 속도를 가진 AI와 동시에 결승점까지 달리기</li>
      </ul>
      <p>
        모드가 늘어나도 <em>입력 처리 → 진행 상황 업데이트 → 출력</em> 단계는 동일하게 유지되도록
        책임을 분리하는 데 신경 썼습니다.
      </p>
    </section>

    <section>
      <h2>3. Quiet Gap으로 치트 방지</h2>
      <p>
        콘솔 게임 특성상 키보드 자동 입력이나 키 홀드로도 입력이 들어올 수 있기 때문에,
        단순히 “입력이 들어왔는가”만 보는 방식으로는 공정한 게임을 만들기 어렵습니다.
      </p>
      <p>
        그래서 각 입력 사이의 시간 간격을 측정해서, 최소 간격(Quiet Gap)을 만족했을 때만
        유효한 탭으로 인정하는 로직을 추가했습니다.
        이 값은 난이도별로 다르게 두어, HARD에서는 더 빡빡하게 체크하도록 구성했습니다.
      </p>
    </section>

    <section>
      <h2>4. nanoTime과 랭킹 파일 저장</h2>
      <p>
        게임 결과는 <code>System.nanoTime()</code>을 이용해 측정한 시간으로 기록하고,
        텍스트 파일에 랭킹 형태로 저장하도록 만들었습니다.
        이미 존재하는 플레이어 이름이라면 더 좋은 기록일 때만 갱신하는 식으로
        업서트(upsert) 로직을 직접 구현했습니다.
      </p>
      <p>
        추후에는 JSON이나 DB로 옮길 수 있도록,
        파일 입출력 부분을 별도 유틸리티 클래스로 분리해 두었습니다.
      </p>
    </section>

    <section>
      <h2>5. 다음 목표</h2>
      <p>
        현재 버전은 콘솔 UI에 집중했기 때문에,
        이후에는 모드 추가보다는 <strong>코드 구조 정리와 테스트 코드</strong>에 초점을 맞추려고 합니다.
        예를 들어 Quiet Gap 로직과 랭킹 정렬 부분은 단위 테스트를 추가해서
        리팩터링에 더 자신 있게 손볼 수 있도록 해볼 계획입니다.
      </p>
    </section>
  </article>
</Layout>

<style>
  .article {
    max-width: 720px;
    margin: 0 auto;
    font-size: 14px;
    line-height: 1.8;
  }

  .article-header {
    margin-bottom: 24px;
  }

  .article-tag {
    display: inline-flex;
    padding: 3px 9px;
    border-radius: 999px;
    background: #fef9c3;
    border: 1px solid #fde68a;
    font-size: 11px;
    color: #854d0e;
  }

  .article-header h1 {
    margin: 10px 0 8px;
    font-size: 22px;
  }

  .article-sub {
    margin: 0 0 10px;
    color: #4b5563;
  }

  .article-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    font-size: 12px;
    color: #6b7280;
  }

  section {
    margin-top: 22px;
  }

  section h2 {
    margin: 0 0 6px;
    font-size: 18px;
  }

  section p {
    margin: 4px 0;
  }

  ul {
    margin: 4px 0 4px 18px;
  }

  code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
      "Liberation Mono", "Courier New", monospace;
    font-size: 12px;
    background: #f3f4f6;
    padding: 2px 4px;
    border-radius: 4px;
  }
</style>
